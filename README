 ____                      
|  _ \  __ ___   _____  
| | | |/ _` \ \ / / _ \ 
| |_| | (_| |\ V /  __/
|____/ \__,_| \_/ \___|

Peer-to-peer DHT on proof-of-work, cuckoo hashing, and gossip over UDP.

Copyright 2024 Joey Innes <joey@inneslabs.uk>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

WARNING: THIS PROJECT HAS JUST STARTED, AND IS NOT FIT FOR PRODUCTION

1.      Constants

EPOCH           1s      Good for now.
MTU             1500    Typical for home WiFi connections.
NPEER           3       Limit to prevent Eclipse attack.
SHARE_DELAY     1m      Do not advertise peers added within the last minute to prevent churn.
TOLERANCE       3       Low tolerance reduces churn & message loss.
DISTANCE        6       Higher value increases probability that all nodes receive packet.
FANOUT          2       Don't flood network.
MINWORK         2       Prevent spam.
FILTER_CAP      1M      Plenty for 1 EPOCH.


2.      Operation Codes

GETPEER     Packet requesting that the remote replies with NPEER random peer descriptors.
PEER        Packet containing NPEER peer descriptors.
SET         Packet containing DAT, remote should verify work, and then store. If len(Peers) < DISTANCE, remote should forward to FANOUT random peers, after appending remote address to message peer descriptors.
GET         Packet requesting DAT, remote should send DAT to all peer descriptors contained in packet.
DAT         Packet containing a value, tag, nonce & PoW.
RAND        Random DAT, pushed to one random peer once per EPOCH.


3.      Message

3. 1.   Message Fields

            DESCRIPTION                             BYTE LENGTH
Op          Operation code.                         1
Peers       List of peer descriptors who forwarded. 20*DISTANCE
Work        SHA256(SHA256(Val, Tag), Nonce).        0 | 32
Nonce       Work salt.                              0 | 32
Tag         Arbitrary metaadata.                    <= 32
Val         The data.                               <= 1200 for MTU=1500,DISTANCE=7

3. 2.   Wire Format

A message is serialized into binary using protobuf. See protobuf spec dave.proto.

Transpiling Protobuf Spec for Go:
#!/bin/bash
protoc --go_out=. dave.proto


4.      Peer Discovery & Liveness

The protocol ensures a cohesive network by combining liveness and peer discovery into a single pair of direct messages (GETPEER & PEER). A node replies to a GETPEER message with a PEER message with up to NPEER peer descriptors. Peers are not advertised if they have not been seen recently.


5.      DAT

DAT is a construct representing a small value, tag (arbitrary 32B), nonce, and proof-of-work. The proof-of-work allows the network to prioritise storage of keys backed by more work, and prevent spam/flooding. The proof, combined with cuckoo hashing, makes the network resilient to protocol deviation.


6.      Message Propagation

6. 1.   Forward with Fanout
Nodes forward SET and GET messages to FANOUT nodes, until forwarded DISTANCE times. Each node appends the peer descriptor of the packet source to the message peer descriptor list.
For the SET operation, if the message contains less than DISTANCE peer descriptors, the message is forwarded to FANOUT random peers, excluding those already in the message.
For the GET operation, if the receiver DOES NOT have the data, and the message contains less than DISTANCE peer descriptors, the message is forwarded to FANOUT random peers, excluding those already in the message.
For the GET operation, if the receiver DOES have the data, the receiver sends a DAT message with the data to all peers in the message peer descriptor list. Each peer can then validate the work & store the DAT.

6. 2. Random Push

Every EPOCH, each node sends one random DAT to one random peer. This ensures reliable propagation, and eventual consistency.


7.      Recently Implemented

7. 1.   Cuckoo Filter

Dropping packets efficiently is fundamental to an app's resilience to DoS attacks.

A naive approach such as a ring-buffer is O(n^2), unsuitable in this case.

Cuckoo filters leverage cuckoo hashing to efficiently store fingerprints in a compact hash table, enabling fast insertions, deletions and lookups. This makes them well-suited for performance-critical applications like packet filtering to improve DoS attack resilience.

Packets that deviate from the protocol are efficiently detected & dropped without unnecessary processing.


8.      In Development

CONSIDERING: Direct messaging between nodes
CONSIDERING: Topic pub/sub

I'm writing a HTTP gatetway, daveg, to serve as a proof of concept, and to quickly find and address usability issues. We can soon build our first web dApp. https://github.com/intob/daveg.
