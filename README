 ____                      
|  _ \  __ ___   _____  
| | | |/ _` \ \ / / _ \ 
| |_| | (_| |\ V /  __/
|____/ \__,_| \_/ \___|

DHT on proof-of-work, cuckoo hashing and gossip over UDP.

Copyright 2024 Joey Innes <joey@inneslabs.uk>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


1.      Constants

EPOCH           127713921ns
MTU             1500
NPEER           3               Limit to prevent Eclipse attack.
SHARE_DELAY     1m              Limit to prevent churn & Sybil attack, we can
                                increase if necessary.
TOLERANCE       3               Low tolerance minimises message loss.
DISTANCE        6               Higher value increases reliability of initial
                                propagation, but more addresses leave less
                                space for value (~1200B with 6).
FANOUT          2               Balance propagation speed, reliability &
                                network load.
MINWORK         2               Minimum difficulty of DAT packets to accept. We
                                can increase to 3 if necessary.
PRUNE           128             Number of epochs between DAT pruning.


2. User Configurable Settings

                SUGGESTED VALUE
FILTER_CAP      1M      Allocates around 1MB. Should be increased to 2, 4 or
                        8M if possible.
DAT_CAP         1M      As large as possible for available memory. ~1304B per
                        DAT.


2.      Operation Codes

GETPEER     Packet requesting that the remote replies with NPEER random peer
            descriptors.
PEER        Packet containing NPEER peer descriptors.
SET         Packet containing DAT, remote should verify work, and then store.
            If len(Peers) < DISTANCE, remote should forward to FANOUT random
            peers, after appending remote address to message peer descriptors.
GET         Packet requesting DAT, remote should send DAT to all peer
            descriptors contained in packet.
DAT         Packet containing a value, tag, nonce & PoW.
RAND        Random DAT, pushed to one random peer once per EPOCH.


3.      Message

3. 1.   Message Fields

            DESCRIPTION                             BYTE LENGTH
Op          Operation code.                         1
Peers       List of peers who forwarded.            20*DISTANCE
Work        SHA256(SHA256(Val, Tag), Nonce).        0 | 32
Nonce       Work salt.                              0 | 32
Tag         Arbitrary metaadata.                    <= 32
Val         The data.                               <= 1200 for MTU=1500,
                                                    DISTANCE=7

3. 2.   Wire Format

A message is serialized into binary using protobuf. See protobuf spec
dave.proto.

Transpiling Protobuf Spec for Go:
#!/bin/bash
protoc --go_out=. dave.proto


4.      Peer Discovery & Liveness

The protocol ensures a cohesive network by combining liveness and peer
discovery into a single pair of direct messages (GETPEER & PEER). A node
replies to a GETPEER message with a PEER message with up to NPEER peer
descriptors. Peers are not advertised if they have not been seen recently.


5.      DAT

DAT is a construct representing a 1200B value, 32B arbitrary tag, 32B nonce,
and 32B proof-of-work. The proof-of-work allows the network to prioritise
storage of newer keys backed by more work, and prevent spam/flooding.

5. 1.   Weight

Calculated as
        weight = difficulty * (1 / secondsSinceAdded)
where difficulty is number of leading zero bytes.

5. 2. Replacement by Weight

Once per PRUNE epochs, a user defined number of heaviest DATs persist, and the
remaining removed.

6.      Message Propagation

6. 1.   Forward

Nodes forward SET and GET messages to FANOUT nodes, until forwarded DISTANCE
times. Each node appends the peer descriptor of the packet source to the
message peer descriptor list.

For the SET operation, if the message contains less than DISTANCE peer
descriptors, the message is forwarded to FANOUT random peers, excluding those
already in the message.

For the GET operation, if the receiver DOES NOT have the data, and the message
contains fewer than DISTANCE peer descriptors, the message is forwarded to
FANOUT random peers, excluding those already in the message.

For the GET operation, if the receiver DOES have the data, the receiver sends a
DAT message with the data to all peers in the message peer descriptor list.
Each peer can then validate the work & store the DAT.


6. 2. Random Push

Every EPOCH, each node sends one random DAT to FANOUT random peers. This ensures
reliable propagation, and eventual consistency.


7.   Packet Filter

Dropping packets efficiently is fundamental to resilience against attack.

Cuckoo filters leverage cuckoo hashing to efficiently store fingerprints in a
compact hash table, enabling fast insertions, deletions and lookups. This makes
them well-suited for performance-critical applications like packet filtering to
improve DoS attack resilience.

Packets that deviate from the protocol are detected & dropped without
further processing.
